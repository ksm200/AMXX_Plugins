/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <sqlx>
#include <colorchat>
#include <hamsandwich>
#include <fun>
#include <cstrike>
#include <engine>
#include <fakemeta_util>
#include <nvault>
#include <jailbreak>


#define prefix "Sklep"

#define FL_WATERJUMP (1<<11) 
#define FL_ONGROUND (1<<9) 
#define	autobhopkeys (1<<0)|(1<<1) 
new const g_sound_explosion[] = "weapons/sg_explode.wav"
new const g_classname_grenade[] = "grenade"

new const Float:g_sign[4][2] = {{1.0, 1.0}, {1.0, -1.0}, {-1.0, -1.0}, {-1.0, 1.0}}

new g_spriteid_steam1
new g_eventid_createsmoke

#define SMOKE_SCALE 30
#define SMOKE_FRAMERATE 12
#define SMOKE_GROUND_OFFSET 6


new pPcvarDBHost;
new pPcvarDBUser;
new pPcvarDBPassword;
new pPcvarDBBase;
new name[33];
new Handle:g_SqlTuple;
new g_Cache[512];
new bool:SQLenabled;
new bool:gIntermission;
new gTablesLoaded[33];
new gSaveKey[33][32];
new eliminator_rozrzutu[33];
new longjump[33], player_b_froglegs[33];
new ilosc_jbpack[33];
new bool:bhop_enabled[33];
new ilosc_he[33], ilosc_flashbang[33], ilosc_smoke[33];
new bool:skoki[33];
new bool:buySkoki[33];
new bool:smoke[33]

new jb_packi_nv
public plugin_init() {
	
	//--//--//--//--//--//--//--//--//--//--//--//--//--//--//
	pPcvarDBHost = register_cvar("db_host", "xx"); //ip bazy danych
	pPcvarDBUser = register_cvar("db_user", "zz"); //nazwa uzytkownika
	pPcvarDBPassword = register_cvar("db_pass", "cc"); //haslo do bazy danych
	pPcvarDBBase = register_cvar("db_database", "vv"); //nazwa bazy danych
	//--//--//--//--//--//--//--//--//--//--//--//--//--//--//
	
	register_clcmd("say /sklep", "jb_sklep")
	register_clcmd("say_team /sklep", "jb_sklep")
	
	register_cvar("jb_maxjp", "1000" );
	register_cvar("jb_tt", "10" );
	register_cvar("jb_ct", "10" );
	register_cvar("jb_hs", "20" );
	register_cvar("jb_zapis", "1"); //1  - nvault, 2 - sql
	
	if(get_cvar_num("jb_zapis") == 2) { 
		jb_packi_nv = nvault_open("jb_packi")
		if(jb_packi_nv == INVALID_HANDLE)
			set_fail_state("Nie moge otworzyc pliku");
	}
	
	register_event("DeathMsg", "DeathMsg", "a")
	register_logevent("Koniec_Rundy", 2, "1=Round_End")
	register_forward(FM_CmdStart, "CmdStart");
	register_concmd("jb_packgiveax", "cmd_give", ADMIN_IMMUNITY, "<nazwa> <ilosc>");
	register_clcmd("typ_zapisu", "typ");
	register_forward(FM_PlayerPreThink, "Prethink_froglegs");
	register_forward(FM_PlayerPreThink, "forward_FM_PlayerPreThink", 0)
	register_forward(FM_EmitSound, "forward_emitsound")
	register_forward(FM_PlaybackEvent, "forward_playbackevent")
	register_forward(FM_CmdStart, "fwCmdStart_MultiJump");

	// we do not precaching, but retrieving the indexes
	g_spriteid_steam1 = engfunc(EngFunc_PrecacheModel, "sprites/steam1.spr")
	g_eventid_createsmoke = engfunc(EngFunc_PrecacheEvent, 1, "events/createsmoke.sc")

	
}

public plugin_precache()
	precache_sound("misc/prosiakjail/cele.wav")

public DeathMsg()
{
	new weaponname[20]
	new kid = read_data(1)
	new vid = read_data(2)
	new headshot = read_data(3)
	read_data(4,weaponname,31)
	
	if(kid == vid)
	{
		return PLUGIN_HANDLED	
	}
	if(get_user_team(kid) == 1)
	{
		new maxjp = get_cvar_num("jb_maxjp")
		if(ilosc_jbpack[kid]<maxjp)
		{
			if(get_user_team(vid) == 2)
			{
				new pack_ct = get_cvar_num("jb_ct")
				ilosc_jbpack[kid] += pack_ct
				ColorChat(kid, GREEN, "[%s] ^x01 Dostales ^x04+%i ^x01 szlugi", prefix, pack_ct);
			}
			else
			{
				new pack_tt = get_cvar_num("jb_tt")
				ilosc_jbpack[kid] += pack_tt
				ColorChat(kid, GREEN, "[%s] ^x01 Dostales ^x04+%i ^x01 szlugi", prefix, pack_tt);
			}
			if(headshot)
			{
				new pack_hs = get_cvar_num("jb_hs")
				ilosc_jbpack[kid] += pack_hs
				ColorChat(kid, GREEN, "[%s] ^x01 Dostales bonus za headshot ^x04+%i ^x01 szlugi", prefix, pack_hs);
			}
		}
		else
		{
			ColorChat(kid, GREEN, "[%s] ^x01 Ilosc maksymalnej ilosci szlugow osiagnieta!", prefix);	
			return PLUGIN_CONTINUE
		}
		ColorChat(kid, GREEN, "[%s] ^x01 Twoja ilosc szlugow to: ^x04%i/%i", prefix, ilosc_jbpack[kid], maxjp);
		if(get_cvar_num("jb_zapis") == 1) { 
			sql_save(kid)
		}
		else
		{
			zapisz_jbpack(kid)
		}
	}
	return PLUGIN_CONTINUE
}


////----//////

public jb_sklep(id)
{	
	
	ColorChat(id, GREEN, "[Sklep] Zasady uzywania sklepu: ");
	ColorChat(id, GREEN, "[Sklep] Szlugi to^x03 waluta wiezienna");
	ColorChat(id, GREEN, "[Sklep] Kupisz za nie rozne^x03 bonusy");
	ColorChat(id, GREEN, "[Sklep] Za zabicie otrzymujesz szlugi");
	new menu,formats[64];
	formatex(formats,charsmax(formats),"\wSklep ze szlugami^n\wMasz: \r%i \w szlugow",ilosc_jbpack[id])
	menu = menu_create(formats,"handle_jb_sklep");
	if(get_user_team(id) == 1)
	{		
		menu_additem(menu,"\rKlucz Do Cel \y[600 szlugow]")
		menu_additem(menu,"\wGranat Wybuchajacy \y[40 szlugow]")
		menu_additem(menu,"\wGranat Oslepiajacy \y[20 szlugow]")
		menu_additem(menu,"\wGranat Dymny \y[15 szlugow]")     
		menu_additem(menu,"\wNajki Zapierdalajki na jedna runde \y[80 szlugow]")
		menu_additem(menu,"\wCichobiegi \y[50 szlugow]")
                menu_additem(menu,"\wDodatkowy skok w powietrzu \y[60 szlugow]")
		menu_additem(menu,"\wKamizelka Kuloodporna \y[80 szlugow]")
		menu_additem(menu,"\wAutoBH na jedna runde \y[60 szlugow]")
		menu_additem(menu,"\wEliminator rozrzutu \y[100 szlugow]")
                menu_additem(menu,"\w50HP \y[70 szlugow]")
		menu_additem(menu,"\wDuszek w nastepnej rundzie \y[200 szlugow]")
		menu_additem(menu,"\wLongjump \y[150 szlugow]")
		menu_additem(menu,"\wDeagle \y[180 szlugow]")
		menu_additem(menu,"\wTeleportujacy smoke \y[20 szlugow]")
	}
	menu_setprop(menu,MPROP_EXIT,MEXIT_ALL)
	menu_setprop(menu,MPROP_EXITNAME,"Wyjscie")
	menu_setprop(menu,MPROP_NEXTNAME,"Dalej")
	menu_setprop(menu,MPROP_BACKNAME,"Wroc")
	menu_display(id,menu,0)
	return PLUGIN_HANDLED
}
public handle_jb_sklep(id, menu, item)
{
	get_user_name(id,name,charsmax(name));
	switch(item)
	{
		case 0:
		{
			if(!sprawdz(id, 600)) return PLUGIN_HANDLED;
			jail_open_cele()
			ColorChat(0, RED, "[Klucz Do Cel]^x01 Gracz o nicku^x04 %s^x01 posiadal^x03 klucz do cel!", name);
			ColorChat(0, RED, "[Klucz Do Cel]^x01 Gracz o nicku^x04 %s^x01 posiadal^x03 klucz do cel!", name);
			ColorChat(0, RED, "[Klucz Do Cel]^x01 Gracz o nicku^x04 %s^x01 posiadal^x03 klucz do cel!", name);
			client_cmd(0, "spk misc/prosiakjail/cele.wav");
		}
		case 1:
		{
			if(ilosc_he[id] < 2){
				if(!sprawdz(id,40)) return PLUGIN_HANDLED;
				give_item(id, "weapon_hegrenade");
				ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles granat wybuchowy", prefix, name);
				ilosc_he[id]++;
			}
		}
		case 2:
		{
			if(ilosc_flashbang[id] < 2){
				if(!sprawdz(id,20)) return PLUGIN_HANDLED;
				give_item(id, "weapon_flashbang");
				ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles granat oslepiajacy", prefix, name);
				ilosc_flashbang[id]++
			}
		}
		case 3:
		{
			if(ilosc_smoke[id] < 2){
				if(!sprawdz(id,15)) return PLUGIN_HANDLED;
				give_item(id, "weapon_smokegrenade");
				ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles granat dymny", prefix, name);
				ilosc_smoke[id]++
			}
		}
		case 4:
		{
			if(!sprawdz(id,80)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles Najki Zapierdalajki", prefix, name);
			set_user_maxspeed(id, 500.0);
		}
		case 5:
		{
			if(!sprawdz(id,50)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles cichobiegi", prefix, name);
			set_user_footsteps(id, 1);
                }
		case 6:
		{
			if(!sprawdz(id,60)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles dodatkowy skok w powietrzu", prefix, name);
			buySkoki[id] = true;
			skoki[id] = true;
		}
		case 7:
		{
			if(!sprawdz(id,30)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles kamizelke kuloodporna", prefix, name);
			set_user_armor(id, 250);
		}
		case 8:
		{
			if(!sprawdz(id,40)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles Bunny hop na jedna runde", prefix, name);
			bhop_enabled[id] = true;
		}
		case 9:
		{
			if(!sprawdz(id,100)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles eliminator rozrzutu", prefix, name);
			eliminator_rozrzutu[id] = true;
                }
                case 10:
		{
			if(!sprawdz(id,70)) return PLUGIN_HANDLED;
			set_user_health(id, get_user_health(id) + 50)
			ColorChat(id, GREEN, "[%s] Kupiles +50HP", prefix);  
		}
		case 11:
		{
			if(!sprawdz(id,200)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles duszka w nastepnej rundzie", prefix, name);
			jail_set_prisoner_ghost(id, false, true);
		}
		case 12:
		{
			if(!sprawdz(id,200)) return PLUGIN_HANDLED;
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kupiles longjumpa", prefix, name);
			ColorChat(id, GREEN, "[%s]^x03 %s -^x01 Kucaj przez 5 sekund, aby aktywowac supermoc", prefix, name);
			longjump[id] = true;
		}
		case 13:
		{
			if(!sprawdz(id,180)) return PLUGIN_HANDLED;
			ColorChat(id, GREY, "[%s]^x03 %s -^x01 kupiles deagla z jednym nabojem",prefix, name);
			new ent = give_item(id, "weapon_deagle");
			if(ent != -1)
				cs_set_weapon_ammo(ent, 1);
		}
		case 14:
		{
			if(!sprawdz(id,20)) return PLUGIN_HANDLED;
			ColorChat(id, GREY, "[%s]^x03 %s -^x01 kupiles teleportujacego smoke",prefix, name);
			give_item(id, "weapon_smokegrenade");
			smoke[id] = true;
			
		}
	}
	return PLUGIN_CONTINUE;
}
public sprawdz(id,jbpack){
	if (ilosc_jbpack[id] >= jbpack){
		ilosc_jbpack[id] -= jbpack
		return true;
	}
	if(!is_user_alive(id)){
		ColorChat(id, GREEN, "[%s]^x01 Nie zyjesz", prefix);
		return false;
	}
	if(ilosc_jbpack[id] < jbpack)
	{
		ColorChat(id, GREEN, "[%s]^x01 Nie masz tylu szlugow, aby to kupic", prefix);
		return false;
	}
	return PLUGIN_CONTINUE;
}


public Koniec_Rundy(){
	for(new i =1;i<33;i++)
	{
		if(is_user_connected(i))
		{
			ilosc_he[i] = 0;
			ilosc_smoke[i] = 0;
			ilosc_flashbang[i] = 0;
			bhop_enabled[i] = false
			set_user_footsteps(i, 0)
			smoke[i] = false;
			buySkoki[i] = false
		}
	}
}

public forward_FM_PlayerPreThink(id) 
{ 
	if(bhop_enabled[id] == true) 
	{ 
		entity_set_float(id, EV_FL_fuser2, 0.0) 
		
		if (entity_get_int(id, EV_INT_button) & 2) 
		{ 
			new flags = entity_get_int(id, EV_INT_flags) 
			
			if (flags & FL_WATERJUMP) 
				return PLUGIN_CONTINUE 
			if ( entity_get_int(id, EV_INT_waterlevel) >= 2 ) 
				return PLUGIN_CONTINUE 
			if ( !(flags & FL_ONGROUND) ) 
				return PLUGIN_CONTINUE 
			
			new Float:velocity[3] 
			entity_get_vector(id, EV_VEC_velocity, velocity) 
			velocity[2] += 250.0 
			entity_set_vector(id, EV_VEC_velocity, velocity) 
			
			entity_set_int(id, EV_INT_gaitsequence, 6) 
		} 
	} 
	return PLUGIN_CONTINUE 
}  
public CmdStart(id, uc_handle)
{
	if(eliminator_rozrzutu[id] && get_uc(uc_handle, UC_Buttons) & IN_ATTACK)
	{
		new Float:punchangle[3]
		pev(id, pev_punchangle, punchangle)
		for(new i=0; i<3;i++)
			punchangle[i]*=0.9;
		set_pev(id, pev_punchangle, punchangle)
	}
}
public Prethink_froglegs(id)
{
	if (longjump[id] && get_user_button(id) & IN_DUCK)
	{
		if (player_b_froglegs[id] == 1)
		{
			player_b_froglegs[id] = floatround(halflife_time())
		}
		else
		{
			if (floatround(halflife_time())-player_b_froglegs[id] >= 5.0) // Tutaj podajemy czas zamiast X
			{
				new Float:fl_iNewVelocity[3]
				VelocityByAim(id, 1000, fl_iNewVelocity)
				fl_iNewVelocity[2] = 210.0
				entity_set_vector(id, EV_VEC_velocity, fl_iNewVelocity)
				player_b_froglegs[id] = 1
			}
		}
	}
	else
	{
		player_b_froglegs[id] = 1
	}
	return PLUGIN_CONTINUE
}


public cmd_give(id, level, cid)
{
	if(!cmd_access(id, level, cid, 3))
		return PLUGIN_CONTINUE;
	
	new arg[33];
	read_argv(1, arg, 32);
	new target = cmd_target(id, arg, CMDTARGET_ALLOW_SELF);
	
	if(!is_user_connected(target))
		return PLUGIN_CONTINUE;
	
	read_argv(2, arg, 32);
	new ilejb = str_to_num(arg);
	
	ilosc_jbpack[target] = ilosc_jbpack[target] + ilejb;
	
	return PLUGIN_CONTINUE;
}

public plugin_natives()
{
	register_native("get_user_jbpack","return_jbpack", 1)
	register_native("set_user_jbpack","set_jbpack", 1)
}

public return_jbpack(id)
{
	return ilosc_jbpack[id];
}
public set_jbpack(id, amount)
{
	ilosc_jbpack[id] = amount	
}


//////////////
public typ(id) {
	if(get_cvar_num("jb_zapis") == 1) { 
		client_print(id, print_console, "Uzywasz obecnie zapisu SQL")
	}
	else
	{
		client_print(id, print_console, "Uzywasz obecnie zapisu nVault")
	}
}

public zaladuj_jbpack(id)
{
	new name[48]
	get_user_name(id,name,47)
	new vaultkey[64],vaultdata[128]
	formatex(vaultkey,63,"%s-jbpack",name)
	
	if(nvault_get(jb_packi_nv,vaultkey,vaultdata,127)) {
		new jb_packii[16];
		parse(vaultdata, jb_packii, 15)
		
		ilosc_jbpack[id]=str_to_num(jb_packii)
	}
	
	return PLUGIN_CONTINUE
}  

public zapisz_jbpack(id) {	
	new name[48]
	get_user_name(id,name,47)
	new vaultkey[64],vaultdata[128]
	formatex(vaultkey,63,"%s-jbpack",name)
	formatex(vaultdata,127,"%d", ilosc_jbpack[id])
	nvault_set(jb_packi_nv,vaultkey,vaultdata)
	
	return PLUGIN_CONTINUE
}

public plugin_cfg(){
	SQLenabled = false;
	sql_init();
}
public plugin_end()
{
	if ( SQLenabled )
	{
		SQL_FreeHandle(g_SqlTuple);
	}
}
public Message_Intermission()
{
	gIntermission = true;
}
public client_putinserver(id){
	gTablesLoaded[id] = 0;
	if(get_cvar_num("jb_zapis") == 1) { 
		get_save_key(id);
	}
	else
	{
		zaladuj_jbpack(id);
	}
}
public client_disconnect(id)
{
	if(get_cvar_num("jb_zapis") == 1) { 
		sql_save(id)
	}
	else
	{
		zapisz_jbpack(id)
	}
}
public sql_init()
{
	new szHost[32], szUser[32], szPass[32], szDB[32];
	get_pcvar_string(pPcvarDBHost, szHost, 31);
	get_pcvar_string(pPcvarDBUser, szUser, 31);
	get_pcvar_string(pPcvarDBPassword, szPass, 31);
	get_pcvar_string(pPcvarDBBase, szDB, 31);
	
	g_SqlTuple = SQL_MakeDbTuple(szHost, szUser, szPass, szDB);
	
	SQL_ThreadQuery(g_SqlTuple, "TableHandle", "CREATE TABLE IF NOT EXISTS jbpacki (nazwa_gracza VARCHAR(35), ilosc_jbpack INT(11), PRIMARY KEY (nazwa_gracza))");
}
public get_save_key(id)
{
	get_user_name(id, gSaveKey[id], charsmax(gSaveKey[]));
	sql_load(id);
}
public sql_load(id)
{
	new index[1];
	index[0] = id;
	
	new tempSaveKey[63];
	copy(tempSaveKey, charsmax(tempSaveKey), gSaveKey[id]);
	replace_all(tempSaveKey, charsmax(tempSaveKey), "'", "\'" );
	
	formatex(g_Cache, charsmax(g_Cache), "SELECT ilosc_jbpack FROM jbpacki WHERE nazwa_gracza='%s'", tempSaveKey);
	SQL_ThreadQuery(g_SqlTuple, "SelectHandle", g_Cache, index, 1);
}
public TableHandle(FailState, Handle:Query, Error[], Errcode, Data[], DataSize)
{
	if ( FailState )
	{
		if ( FailState == TQUERY_CONNECT_FAILED )
		{
			log_amx("Table - Could not connect to SQL database.  [%d] %s", Errcode, Error);
		}
		else if ( FailState == TQUERY_QUERY_FAILED )
		{
			log_amx("Table Query failed. [%d] %s", Errcode, Error);
		}
		
		SQLenabled = false;
		
		return;
	}
	
	SQLenabled = true;
}

public QueryHandle(FailState, Handle:Query, Error[], Errcode,Data[], DataSize)
{
	if ( FailState )
	{
		if ( FailState == TQUERY_CONNECT_FAILED )
		{
			log_amx("Save - Could not connect to SQL database.  [%d] %s", Errcode, Error);
		}
		else if ( FailState == TQUERY_QUERY_FAILED )
		{
			log_amx("Save Query failed. [%d] %s", Errcode, Error);
		}
		
		return;
	}
}

public SelectHandle(FailState, Handle:Query, Error[], Errcode, Data[], DataSize)
{
	if ( FailState )
	{
		if ( FailState == TQUERY_CONNECT_FAILED )
		{
			log_amx("Load - Could not connect to SQL database.  [%d] %s", Errcode, Error);
		}
		else if ( FailState == TQUERY_QUERY_FAILED )
		{
			log_amx("Load Query failed. [%d] %s", Errcode, Error);
		}
		
		return;
	}
	
	new id = Data[0];
	
	if ( !SQL_NumResults(Query) )
	{
		new tempSaveKey[63];
		copy(tempSaveKey, charsmax(tempSaveKey), gSaveKey[id]);
		replace_all(tempSaveKey, charsmax(tempSaveKey), "'", "\'" );
		
		formatex(g_Cache, charsmax(g_Cache), "INSERT INTO jbpacki VALUES('%s', '0')", tempSaveKey);
		SQL_ThreadQuery(g_SqlTuple, "QueryHandle", g_Cache);
	}
	else
	{
		ilosc_jbpack[id] = SQL_ReadResult(Query,SQL_FieldNameToNum(Query,"ilosc_jbpack"));
	}
	gTablesLoaded[id]++;
}

public sql_save(id)
{
	if ( gTablesLoaded[id] == 1 )
	{
		if ( gIntermission )
		{
			sql_save_nonthreaded(id);
			return;
		}
		new tempSaveKey[63];
		copy(tempSaveKey, charsmax(tempSaveKey), gSaveKey[id]);
		replace_all(tempSaveKey, charsmax(tempSaveKey), "'", "\'" );
		
		formatex(g_Cache, charsmax(g_Cache), "UPDATE jbpacki SET ilosc_jbpack=%i WHERE nazwa_gracza=^"%s^"", ilosc_jbpack[id], tempSaveKey);
		SQL_ThreadQuery(g_SqlTuple, "QueryHandle", g_Cache);
	}
}

sql_save_nonthreaded(id)
{
new Errcode, Error[128], Handle:SqlConnection;

SqlConnection = SQL_Connect(g_SqlTuple, Errcode, Error, charsmax(Error));

if ( !SqlConnection )
{
	log_amx("Save - Could not connect to SQL database.  [%d] %s", Errcode, Error);
	SQL_FreeHandle(SqlConnection);
	return;
}

new tempSaveKey[63];
copy(tempSaveKey, charsmax(tempSaveKey), gSaveKey[id]);
replace_all(tempSaveKey, charsmax(tempSaveKey), "'", "\'" );

new Handle:Query;
Query = SQL_PrepareQuery(SqlConnection, "UPDATE jbpacki SET ilosc_jbpack=%i WHERE nazwa_gracza=^"%s^"", ilosc_jbpack[id], tempSaveKey);
if ( !SQL_Execute(Query) )
{
	Errcode = SQL_QueryError(Query, Error, charsmax(Error));
	log_amx("Save Query failed. [%d] %s", Errcode, Error);
	SQL_FreeHandle(Query);
	SQL_FreeHandle(SqlConnection);
	return;
}

SQL_FreeHandle(Query);

SQL_FreeHandle(SqlConnection);
}

public forward_emitsound(ent, channel, const sound[])
{
	static id, Float:origin[3]
	id = pev(ent, pev_owner)

	if (!smoke[id] || !equal(sound, g_sound_explosion) || !is_grenade(ent))
		return FMRES_IGNORED

	pev(ent, pev_origin, origin)
	engfunc(EngFunc_EmitSound, ent, CHAN_WEAPON, g_sound_explosion, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)
	engfunc(EngFunc_RemoveEntity, ent)
	origin[2] += SMOKE_GROUND_OFFSET
	create_smoke(origin)

	if (is_user_alive(id))
	{
		new Float:mins[3], hull
		pev(id, pev_mins, mins)
		origin[2] -= mins[2] + SMOKE_GROUND_OFFSET
		hull = pev(id, pev_flags) & FL_DUCKING ? HULL_HEAD : HULL_HUMAN
		if (is_hull_vacant(origin, hull))
			engfunc(EngFunc_SetOrigin, id, origin)
		else { // close to a solid object, trying to find a vacant spot
			static Float:vec[3]
			vec[2] = origin[2]
			for (new i; i < sizeof g_sign; ++i) {
				vec[0] = origin[0] - mins[0] * g_sign[i][0]
				vec[1] = origin[1] - mins[1] * g_sign[i][1]
				if (is_hull_vacant(vec, hull)) {
					engfunc(EngFunc_SetOrigin, id, vec)
					break
				}
			}
		}
	}

	return FMRES_SUPERCEDE
}

public forward_playbackevent(flags, invoker, eventindex) {
	// we do not need a large amount of smoke
	if (is_user_connected(invoker) && smoke[invoker] && eventindex == g_eventid_createsmoke)
		return FMRES_SUPERCEDE

	return FMRES_IGNORED
}

bool:is_grenade(ent) {
	if (!pev_valid(ent))
		return false

	static classname[sizeof g_classname_grenade + 1]
	pev(ent, pev_classname, classname, sizeof g_classname_grenade)
	if (equal(classname, g_classname_grenade))
		return true

	return false
}

create_smoke(const Float:origin[3]) {
	// engfunc because origin are float
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, origin, 0)
	write_byte(TE_SMOKE)
	engfunc(EngFunc_WriteCoord, origin[0])
	engfunc(EngFunc_WriteCoord, origin[1])
	engfunc(EngFunc_WriteCoord, origin[2])
	write_short(g_spriteid_steam1)
	write_byte(SMOKE_SCALE)
	write_byte(SMOKE_FRAMERATE)
	message_end()
}

stock bool:is_hull_vacant(const Float:origin[3], hull) {
	new tr = 0
	engfunc(EngFunc_TraceHull, origin, origin, 0, hull, 0, tr)
	if (!get_tr2(tr, TR_StartSolid) && !get_tr2(tr, TR_AllSolid) && get_tr2(tr, TR_InOpen))
		return true
	
	return false
}

public fwCmdStart_MultiJump(id, uc_handle)
{
	if(!is_user_alive(id) || !buySkoki[id])
		return FMRES_IGNORED;

	new flags = pev(id, pev_flags);

	if((get_uc(uc_handle, UC_Buttons) & IN_JUMP) && !(flags & FL_ONGROUND) && !(pev(id, pev_oldbuttons) & IN_JUMP) && skoki[id])
	{
		skoki[id] = false
		new Float:velocity[3];
		pev(id, pev_velocity,velocity);
		velocity[2] = random_float(265.0,285.0);
		set_pev(id, pev_velocity,velocity);
	}
	else if(flags & FL_ONGROUND)
		skoki[id] = true;
	 
	return FMRES_IGNORED;
}
